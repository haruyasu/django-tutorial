{"./":{"url":"./","title":"ブログ構築","keywords":"","body":"ブログ構築 自己紹介 はじめまして、フリーランスプログラミング講師のHaru(@hathle)です。 エンジニア歴13年目で海外就労も経験しています。 普段は、Python、Djangoをメインにオンラインでマンツーマンレッスンをしています。 目標に向かって一緒に頑張っていきましょう！！ お問い合わせなどは、Twitterからお願いいたします。 はじめに 今回は、初心者向けのDjangoアプリ開発チュートリアルです。 すぐにDjangoを使ってアプリ開発をしてみたい方向けの内容になっています。 このチュートリアルを実装すると、Webアプリケーションを公開することができます。 シンプルなブログを作って、Djangoの機能を理解していきましょう。 バージョン Python：3.7 Django：2.2 ※Djangoの最新バージョンは3.0ですが、2系と3系では変更点が多いので、情報が多い2系を使用して下さい。 エラーが発生した場合 詳しいコードの解説は、Djangoの公式ページを参考にして下さい。 https://docs.djangoproject.com/ja/2.2/ もしエラーが発生したり、分かりにくい箇所は下記のGitHubにてソースコードを参考にして下さい。 https://github.com/haruyasu/django-template-upgrade2 目標 ブログサイトを構築することを目標にします。 https://django-template-blog-upgrade2.herokuapp.com/ 機能 ログイン、ログアウト、サインアップ ブログ投稿、編集、削除、コメント 固定ページ 前提知識 Djangoを始める前に、下記の言語は学習しておいて下さい。 Python HTML CSS JavaScript では、始めて行きましょう！！ "},"docs/01_ready.html":{"url":"docs/01_ready.html","title":"前準備","keywords":"","body":"準備 GitHub GitHubのアカウントを取得して下さい。 https://github.com/ 「New repository」をクリックして、好きな名前でGitHubのリポジトリを作成します。 ローカルにリポジトリ名と同じフォルダを作成します。 ローカルフォルダとGitHubのリポジトリを連携します。 echo \"# django-blog\" >> README.md git init git add README.md git commit -m \"first commit\" git remote add origin https://github.com/haruyasu/django-blog.git git push -u origin master ※作成したリポジトリ名に変更します。 この時点でREADME.mdだけコミットされていると思います。 gitignoreファイルを追加 ルートディレクトリに.gitignoreファイルを作成します。 django-blog ├── README.md └───.gitignore 記述されたファイルは、git管理下から除外されてコミットされなくなります。 .gitignore myvenv db.sqlite3 .vscode __pycache__ *.pyc 仮想環境 仮想環境を作成します。 仮想環境とは 開発を行うときは、用途に応じて専用の実行環境を作成し、切り替えて使用するのが一般的です。 一時的に作成する実行環境を「仮想環境」と言います。 仮想環境作成 仮想環境はpythonに標準搭載されている仮想環境プログラムの「venv」を使用します。 ルートディレクトリで下記コマンドを入力します。(django-blogフォルダの中) $ python3 -m venv myvenv コマンドを実行すると、myvenvフォルダが作成されます。 VS Codeを使用している方は、エクスプローラーをリフレッシュすると、フォルダが表示されます。 django-blog ├── README.md ├── .gitignore └───myvenv 仮想環境実行 sourceコマンドで仮想環境が実行できます。 ルートディレクトリで下記コマンドを入力します。 Linux、Mac $ source myvenv/bin/activate Windows $ .\\myvenv\\Scripts\\activate 最新pipコマンド pipコマンドをアップデートしておきましょう。 現在、古いコマンドがインストールされています。 (myvenv) ~$ pip3 install --upgrade pip setuptools 環境準備 環境を準備するのに下記のコマンドを入力してください。 Macの場合 (myvenv) ~$ brew install postgresql もしbrewコマンドが認識されない場合は、brewをインストールしてください。 https://brew.sh/index_ja Linuxの場合 sudo apt-get install python3-dev libpq-dev Djangoパッケージをインストール requirements.txtを作成し、開発に必要なパッケージをインストールします。 django-blog ├── README.md ├── .gitignore ├── myvenv │ └── ... └───requirements.txt requirements.txtに各パッケージを記載します。 requirements.txt Django~=2.2 django-heroku==0.3.1 gunicorn==19.9.0 ※ django-herokuはHerokuにデプロイする時に必要なパッケージです。 pip3 installコマンドでrequirements.txtに記載されたパッケージをインストールします。 (myvenv) ~$ pip3 install -r requirements.txt django-herokuをインストールすると、他のパッケージも複数同時にインストールされます。 "},"docs/02_project.html":{"url":"docs/02_project.html","title":"プロジェクトの作成","keywords":"","body":"プロジェクトの作成 Djangoの仕組み DjangoはMTVモデルを採用しています。 下記のイニシャルを取ったものです。 Model(データベースに格納されているデータ) Template(テンプレートファイルによって定義されたそれぞれのページのデザイン) View(どのページを表示させるかを決定する処理) 用語説明 ルーティング(urls.py) URLからどのアプリケーションやビューに処理を渡すかを指定します。 ビュー(views.py) モデルにデーターベース操作を指示し、テンプレートに表示用のデータを渡します。 フォーム(forms.py) フォーム画面で入力されたデータを保持します。 モデル(models.py) データベースと連携します。 テンプレート(xxx.html) HTMLのテンプレートにビューから受け取ったデータを埋め込み表示します。 プロジェクト作成 Djangoは1つのプロジェクトと1つ以上のアプリケーションで構築します。 複数のアプリケーションを作成して、互いに依存しないようにすると、管理が楽になります。 django-admin startprojectコマンドでプロジェクトを作成します。 (myvenv) ~$ django-admin startproject mysite . 環境設定変更 settings.pyを修正してプロジェクトの設定を変更します。 mysite/settings.py ALLOWED_HOSTS = ['*'] LANGUAGE_CODE = 'ja' TIME_ZONE = 'Asia/Tokyo' STATIC_URL = '/static/' STATIC_ROOT = os.path.join(BASE_DIR, 'static') データベースのセットアップ migrateコマンドをすることでデータベースがセットアップされます。 (myvenv) ~$ python3 manage.py migrate Webサーバーを起動する (myvenv) ~$ python3 manage.py runserver URLにアクセスすると、Webページが表示されます。 http://127.0.0.1:8000/ Webサーバーを停止するには、Ctrl + Cを同時に押すと停止します。 "},"docs/03_app.html":{"url":"docs/03_app.html","title":"新しいアプリケーションの作成","keywords":"","body":"新しいアプリケーションの作成 アプリケーションを作成していきます。 startappコマンドでアプリケーションを追加できます。 今回はブログを作成するので、名前はblogにします。 (myvenv) ~$ python3 manage.py startapp blog ├── blog │ ├── admin.py │ ├── apps.py │ ├── __init__.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── tests.py │ └── views.py ├── db.sqlite3 ├── manage.py ├── mysite │ ├── __init__.py │ ├── settings.py │ ├── urls.py │ └── wsgi.py ├── myvenv │ └── ... └── requirements.txt このようなディレクトリが自動的に生成されます。 Djangoでアプリケーションを使えるように設定 アプリケーションを使えるようにするには、プロジェクトの設定にアプリケーションを追加する必要があります。 INSTALLED_APPSに追加します。 mysite/settings.py # Application definition INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog.apps.BlogConfig', # 追加 ] 次は、モデルを作成していきます。 "},"docs/04_models.html":{"url":"docs/04_models.html","title":"モデルの作成","keywords":"","body":"モデルの作成 Djangoではモデルをとおして、データベースを構築します。 モデルを使用することで、SQLを意識することなくデータベースを操作することができます。 モデルを定義するにはmodels.pyに追加します。 まずは、投稿機能を作成していきます。 Postモデルを追加します。 クラスを追加し、各プロパティを定義していきます。 ForeignKey、CharField、TextField、DateTimeFieldなどのフィールド解説は公式ドキュメントを参考にして下さい。 https://docs.djangoproject.com/ja/2.2/ref/models/fields/#charfield フィールドクラス ForeignKey 多対1の関係で他のモデルへのリンク CharField 文字列のフィールド TextField 多量のテキストのフィールド DateTimeField 日付と時刻のフィールド IntegerField 整数のフィールド FloatField 小数のフィールド フィールドオプション フィールドクラスで使えるオプションです。 null データベースのNULL可否を設定 blank フォームフィールドのブランク可否を設定 choices フォームの選択枠を設定 default デフォルト値を設定 unique ユニーク制約を設定 verbose_name フィールド名を設定 validators バリデーションの設定 リレーションフィールドクラス ForeignKeyを使用すると、モデルクラス間で関連付けをすることができます。 OneToOneField 1 対 1 ForeignKey 1 対 多 ManyToManyField 多 対 多 on_deleteオプション models.CASCADE 一緒に削除される models.PROTECT 削除できない models.SET_NULL NULLがセットされる models.SET_DEFAULT デフォルト値がセットされる models.SET 任意の値がセットされる DO_NOTHING 何もしない モデルを作成 blog/models.py from django.conf import settings from django.db import models from django.utils import timezone from django.urls import reverse class Post(models.Model): author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE) title = models.CharField(max_length=200) text = models.TextField() created_date = models.DateTimeField(default=timezone.now) published_date = models.DateTimeField(blank=True, null=True) def publish(self): self.published_date = timezone.now() self.save() def get_absolute_url(self): return reverse(\"post_detail\", kwargs={'pk':self.pk}) def __str__(self): return self.title データベースにモデルのためのテーブルを作成 モデルを変更したら、下記コマンドで必ずデータベースの再構築が必要になります。 (myvenv) ~$ python3 manage.py makemigrations blog (myvenv) ~$ python3 manage.py migrate blog "},"docs/05_admin.html":{"url":"docs/05_admin.html","title":"管理画面の作成","keywords":"","body":"管理画面の作成 Djangoには管理画面が存在します。 管理画面では投稿や編集、削除などweb上でデータベースを操作することができる便利画面です。 作成したモデルを管理画面で見えるようにします。 blog/admin.py from django.contrib import admin from .models import Post admin.site.register(Post) 管理ユーザー作成 createsuperuserコマンドで管理ユーザーを作成することができます。 (myvenv) ~$ python3 manage.py createsuperuser ユーザー名、メールアドレス、パスワードを入力します。 ※パスワードは見えないので、間違えずに入力して下さい。 Webサーバー開始 (myvenv) ~$ python3 manage.py runserver http://127.0.0.1:8000/admin/ ユーザー名とパスワードを入力すると、管理画面が表示されます。 「Posts」をクリックして「POSTを追加」ボタンで、記事を追加してみて下さい。 "},"docs/06_urls.html":{"url":"docs/06_urls.html","title":"URLの作成","keywords":"","body":"URLの作成 ルーティングを設定します。 ルーティングはurls.pyに定義します。 ルーティングはプロジェクト用とアプリケーション用が存在します。 プロジェクト用ルーティング プロジェクト用ルーティングは、管理サイト用のルーティングになります。 include関数でアプリケーションのurlsに処理をすることを指定します。 アプリケーション用ルーティング アプリケーション用のルーティングは、URLとビューのマッチングをします。 このファイルは自動生成されないので、作成する必要があります。 プロジェクト用ルーティングを作成 トップページにアクセスした時には、blog.urlsへリダイレクトするようにします。 mysite/urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('', include('blog.urls')), #追加 ] アプリケーション用ルーティングを作成 blogの下に、urls.pyファイルを作成します。 トップページにviewのPostListViewを割り当てます。 トップページにアクセスした時に、PostListViewをみることになります。 as_viewメソッドは、クラスビューをビュー関数化する働きをします。 クラスビューを使用する場合は必須になります。 blog/urls.py from django.urls import path from blog import views urlpatterns = [ path('', views.PostListView.as_view(), name='post_list'), ] 次は、viewのPostListViewを作ります。 "},"docs/07_views.html":{"url":"docs/07_views.html","title":"Viewの作成","keywords":"","body":"Viewの作成 ビューは、ルーティングからの情報を受け取ってレスポンスの情報を作ります。 ビューの機能 フォームに処理を依頼 モデルにデータベースの操作を依頼 テンプレートにHTMLの生成を依頼 画面遷移先の判断 ビューの種類 ビューの種類は、クラスベース汎用ビューと関数ベースビューがあります。 クラスベース汎用ビューとは？ クラスベース汎用ビューは、すでにビューとしての機能を備えていて、継承して使用します。 https://docs.djangoproject.com/ja/2.2/topics/class-based-views/ これを使用すると、記述する量が減り、簡単にViewを作成することができます。 クラスベース汎用ビューの種類 django.views.genericに、それぞれのビューが準備されているので、importして継承します。 TemplateView テンプレートを使用して、何かを表示する汎用ビュー ListView 一覧を表示する汎用ビュー DetailView 詳細ページを表示する汎用ビュー CreateView 新しくデータを追加するフォームを提供する汎用ビュー UpdateView データを更新するフォームを提供する汎用ビュー DeleteView データを削除する汎用ビュー RedirectView リダイレクトに特化した汎用ビュー FormView フォーム処理をする汎用ビュー 設定した変数を使用 設定した変数を使用したい場合には、汎用ビューで定義されている関数をオーバーライドします。 get_context_data関数を使用すると、使用したい変数に変えることができます。 普段はデフォルト値を使用して、変更したい時だけ値をオーバーライドします。 独自のテンプレートの名前を使用したい場合は、template_nameをオーバーライドします。 オーバーライドするクラス変数 template_name テンプレート名を指定する model モデルを指定する paginate_by 1ページに表示する件数を指定する queryset テンプレートにクエリセットを渡す form_class フォームクラス名を指定する success_url 処理成功時にリダイレクトURLを指定する fields ビューで使うフォームのフィールドを指定する オーバーライドするメソッド get_context_data テンプレートに辞書データを渡す get_queryset テンプレートにクエリセットを渡す form_valid フォームのバリデーションに問題がない場合の処理 form_invalid フォームのバリデーションに問題があった場合の処理 get_success_url 処理成功時のリダイレクトURLを指定 delete 削除処理時の処理を追加 get 独自のGET通信時の処理を記述 post 独自のPOS通信時の処理を記述 関数ベースビュー 関数ベースビューは、ビューで必要なレスポンスを返すreturn処理まで記述する必要があります。 Viewを作成 先程、トップページにアクセスしたときに、viewのPostListViewを指定したので、viewにPostListViewクラスを作成します。 投稿のリストを表示したいので、引数にクラスベース汎用ビューであるListViewを指定します。 blog/views.py from blog.models import Post from django.views.generic import (ListView) class PostListView(ListView): model = Post template_name = \"blog/post_list.html\" 次は、テンプレートのpost_list.htmlを作成します。 "},"docs/08_html.html":{"url":"docs/08_html.html","title":"HTMLの作成","keywords":"","body":"HTMLの作成 先程、viewでpost_list.htmlを表示するように指定したので、post_list.htmlを作成していきます。 blogの下にtemplatesフォルダとblogフォルダを追加します。 blog └───templates └───blog 作成したblogフォルダにpost_list.htmlファイルを追加します。 まずは最小限のHTMLを追加してみましょう。 blog/templates/blog/post_list.html Hello! This is working. Webサーバー開始 (myvenv) ~$ python3 manage.py runserver http://127.0.0.1:8000/ トップページに文字が表示されましたでしょうか！ Hello! This is working. "},"docs/09_dynamic.html":{"url":"docs/09_dynamic.html","title":"動的データの作成","keywords":"","body":"動的データの作成 動的に変わるデータはViewで処理をします。 そして、get_queryset関数でテンプレートにクエリセットを渡します。 クエリとは データベースからデータを取得するための記述方法です。 クエリセットとは クエリの実行結果をクエリセットと呼びます。 公式ドキュメント https://docs.djangoproject.com/ja/2.2/topics/db/queries/ blog/views.py from django.utils import timezone from blog.models import Post from django.views.generic import (ListView) class PostListView(ListView): model = Post template_name = \"blog/post_list.html\" def get_queryset(self): return Post.objects.filter(published_date__lte=timezone.now()).order_by('-published_date') ここでは、filter関数を使用して、公開順に投稿を並べるように指定しています。 "},"docs/10_templates.html":{"url":"docs/10_templates.html","title":"テンプレートの作成","keywords":"","body":"テンプレートの作成 DjangoはHTMLの中にテンプレート言語という記述を用いて、データベースの値を表示したり、条件分岐やループなどの制御をすることができます。 テンプレートは、templatesというディレクトリに.html拡張子で作成する必要があります。 変数を表示 変数を表示するためには、{{ 変数名 }}を使用します。 制御処理 条件分岐やループなどの制御処理は、{ % % }を使用します。 デフォルトで使用可能な変数 user アクセスユーザー情報 objectまたはモデル名 ビューから渡されるモデルオブジェクト object_listまたはモデル名_list ビューから渡されるモデルオブジェクトのリスト message メッセージリスト form フォームオブジェクト 組み込みフィルタ 変数にフィルタを使用することができます。 {{ var|default:''}} {{ var|default_if_none:''}} {{ var|linebreaksbr }} {{ var|safe }} {{ var|truncatechars:100 }} {{ var|urlize }} default 変数がFalseの場合に表示する値を指定 default_if_none 変数がNoneの場合に表示する値を指定 linebreaksbr 改行コード「\\n」をHTMLの「br」に変換 safe 自動エスケープを無効化する truncatechars 指定した文字数を超えた場合は...と表示する urlize URLとメールアドレスをHTMLのアンカータグ「a」で表示する 組み込みタグ autoescape 自動エスケープ機能を制御する block 子テンプレートの内容に置き換える extends 親テンプレートを拡張することを宣言する for, endfor ループする if, elif, else, endif 条件分岐する load カスタムテンプレートタグを読み込む url URLを逆引きする form変数オプション as_p タグで各フィールドを描画 as_table テーブル形式で各フィールドを描画 as_ul リスト形式で各フィールドを描画 テンプレートを作成 デフォルト値のpost_listを使用して、投稿のリストを表示します。 ListViewを使用した場合、モデル名に「_list」を付けた名前がデフォルトで使用されます。 forと指定することで、post_listのリストをループして一つずつ表示することができます。 blog/templates/blog/post_list.html Django Startup Template Django Startup Template {% for post in post_list %} published: {{ post.published_date }} {{ post.title }} {{ post.text|linebreaksbr }} {% endfor %} 管理画面でPostをPublish Published dataを追記します。 Webサーバー開始 (myvenv) ~$ python3 manage.py runserver http://127.0.0.1:8000/ 投稿した内容が表示されます。 "},"docs/11_css.html":{"url":"docs/11_css.html","title":"CSSの作成","keywords":"","body":"CSSの作成 CSSを適応して、見た目を変えていきます。 staticフォルダ、cssフォルダを作成し、blog.cssファイルを作成します。 └── blog └── static └── css └── blog.css 今回は、下記のテンプレートを使用してブログを作成していきます。 https://startbootstrap.com/themes/clean-blog/ CSSの内容は、githubの内容をコピーして貼り付けておいて下さい。 blog/static/css/blog.css https://github.com/haruyasu/django-template-upgrade2/blob/master/blog/static/css/blog.css トップページを変更 Bootstrapを使用して、トップページを変更してみましょう。 Bootstrapの詳しい内容は公式ドキュメントを参考にして下さい。 https://getbootstrap.com/ blog.cssはstatic 'css/blog.css'を指定することで読み込むことができます。 blog/templates/blog/post_list.html {% load static %} Blog - Django Startup Blog Menu Home Django Startup This is your first step! {% for post in post_list %} {{ post.title }} {{ post.published_date }} {{ post.text|linebreaksbr|truncatechars:100 }} {% endfor %} Copyright &copy; Your Website 2020 Webサイトを更新すると、CSSが反映されています。 一気にブログになったと思います。 "},"docs/12_template_extending.html":{"url":"docs/12_template_extending.html","title":"テンプレートの拡張","keywords":"","body":"テンプレートの拡張 HTMLの共通部分を別のページでも使えるようにします。 こうすることで、ヘッダーやフッターなど各ページで同じことを書く必要がなくなります。 base.html 先ほど変更したpost_list.htmlをコピーして、base.htmlを作成します。 blog └───templates └───blog ├── base.html └── post_list.html base.htmlのheader部分とcontent部分の内容を変更します。 block xxxとendblock囲います。 xxxの部分は好きな名前に変えて下さい。 同じファイルにいくつもblockテンプレートタグを書くことができます。 blog/templates/blog/base.html {% block header %} {% endblock %} {% block content %} {% endblock %} post_list.html post_list.htmlの中身をすべて削除し、下記内容に書き換えます。 動的に変わる部分だけをpost_list.htmlに記載します。 今回はblock headerとblock contentの内容が投稿内容によって変わります。 先頭にはextends 'blog/base.html'を追記し、テンプレートを拡張することを指定します。 blog/templates/blog/post_list.html {% extends 'blog/base.html' %} {% block header %} Django Startup This is your first step! {% endblock %} {% block content %} {% for post in post_list %} {{ post.title }} {{ post.published_date }} {{ post.text|linebreaksbr|truncatechars:100 }} {% endfor %} {% endblock %} "},"docs/13_application_extending.html":{"url":"docs/13_application_extending.html","title":"アプリケーションの拡張","keywords":"","body":"アプリケーションの拡張 投稿の詳細ページを作成します。 詳細ページのリンクを作成 post_list.htmlを変更しましょう。 タイトルのリンクを設定します。 url 'post_detail' pk=post.pkとすることで詳細ページへのリンクを張ることができます。 名前をpost_detailとします。 blog/templates/blog/post_list.html {{ post.title }} 詳細ページのURLを作成 URLのパターンを指定します。 blog/urls.py urlpatterns = [ path('', views.PostListView.as_view(), name='post_list'), path('post//', views.PostDetailView.as_view(), name='post_detail'), ] 詳細ページのViewを追加 view.pyにPostDetailViewクラスを追加します。 blog/views.py from django.views.generic import (ListView, DetailView) class PostDetailView(DetailView): model = Post template_name = \"blog/post_detail.html\" 詳細ページのテンプレートを追加 post_detail.htmlファイルを追加します。 blog/templates/blog/post_detail.html {% extends 'blog/base.html' %} {% block header %} {{ post.title }} {% if post.published_date %} {{ post.published_date }} {% endif %} {% endblock %} {% block content %} {{ post.text|linebreaksbr }} {% endblock %} トップページで投稿したタイトルをクリックすると、詳細画面が表示されました。 次は、投稿フォームを作成していきましょう。 "},"docs/14_forms.html":{"url":"docs/14_forms.html","title":"フォームの作成","keywords":"","body":"フォームの作成 フォームは、フォーム画面で入力された値をフォームオブジェクトに変換、保持します。 入力値のチェックもおこないます。 https://docs.djangoproject.com/ja/2.2/ref/forms/fields/ フォームの定義 フォームはdjango.forms.ModelFormクラスを継承して定義します。 django.forms.Formを継承する場合もあります。 フォームのフィールドクラス フィールドクラスにはウィジェットが設定されています。 ウィジェットはフィールドのタイプやデザインをまとめたものです。 CharField TextInput IntegerField NumberInput ChoiceField Select DataField DataInput DataTimeField DataTimeInput EmailField EmailInput FileField ClearableFileInput ImageField ClearableFileInput バリデーション追加 validatorsを使用 clean_メソッドを使用 cleanメソッドを使用 フォームを作成 forms.pyファイルを追加します。 blog └── forms.py フィールドはタイトルと内容にします。 blog/forms.py from django import forms from .models import Post class PostForm(forms.ModelForm): class Meta: model = Post fields = ('author', 'title', 'text') フォームページのリンクを作成 Aboutの下にPostリンクを追加します。 blog/templates/blog/base.html Post フォームページのURLを作成 post/new/のURLを追加します。 blog/urls.py urlpatterns = [ path('', views.PostListView.as_view(), name='post_list'), path('post//', views.PostDetailView.as_view(), name='post_detail'), path('post/new/', views.CreatePostView.as_view(), name='post_new'), ] フォームページのViewを作成 viewに追加してテンプレートを指定します。 blog/views.py from blog.forms import PostForm from django.views.generic import (ListView, DetailView, CreateView) class CreatePostView(CreateView): template_name = \"blog/post_form.html\" form_class = PostForm model = Post フォームページのテンプレートを作成 post_form.htmlファイルを追加します。 blog/templates/blog/post_form.html {% extends 'blog/base.html' %} {% block header %} New post {% endblock %} {% block content %} {% csrf_token %} {{ form.as_p }} Save {% endblock %} フォームの保存動作を作成 保存ボタンを押したときに、詳細ページに移動するように修正します。 post_detailにリダイレクトします。 viewのCreatePostView関数を書き換えます。 blog/views.py class CreatePostView(CreateView): template_name = \"blog/post_form.html\" redirect_field_name = 'blog/post_detail.html' form_class = PostForm model = Post フォームの編集動作を作成 投稿された内容を編集するボタンを追加します。 Editボタンを作成 post.textの上にEditボタンを追加します。 blog/templates/blog/post_detail.html Edit {{ post.text|linebreaksbr }} Editのリンクを作成 Editボタンを押した後のリンクを追加します。 blog/urls.py urlpatterns = [ ... path('post//edit/', views.PostUpdateView.as_view(), name='post_edit'), ] EditのViewを作成 post_form関数をviewに追加します。 post_newとの違いは、instance=postとしてインスタンスを渡しています。 blog/views.py from django.views.generic import (ListView, DetailView, CreateView, UpdateView) class PostUpdateView(UpdateView): template_name = \"blog/post_form.html\" redirect_field_name = 'blog/post_detail.html' form_class = PostForm model = Post これで、ブログ投稿、編集ができるアプリケーションが完成しました。 "},"docs/15_security.html":{"url":"docs/15_security.html","title":"セキュリティ対策","keywords":"","body":"セキュリティ対策 ブログの投稿、編集はログインしている人だけにできるように変更しましょう。 投稿ボタンや編集ボタンをログインしている人だけに、表示するように制限することができます。 if user.is_authenticatedを使用すると、ログインユーザーだけに制限します。 Postボタン blog/templates/blog/base.html {% if user.is_authenticated %} Post {% endif %} Editボタン blog/templates/blog/post_detail.html {% if user.is_authenticated %} Edit {% endif %} これでログインユーザーだけに制限できました。 "},"docs/16_drafts.html":{"url":"docs/16_drafts.html","title":"下書き機能の追加","keywords":"","body":"下書き機能の追加 今までは投稿するとすぐに公開されましたが、下書きに保存することができます。 Draftボタンを作成 ナビゲーションにDraftボタンを追加します。 blog/templates/blog/base.html Draft 下書きのurlを作成 urlはdrafts/にします。 blog/urls.py path('drafts/', views.DraftListView.as_view(), name='post_draft_list'), 下書きのViewを作成 下書きのviewを追加します。 blog/views.py class DraftListView(ListView): login_url = '/login/' template_name = 'blog/post_draft_list.html' model = Post def get_queryset(self): return Post.objects.filter(published_date__isnull=True).order_by('created_date') 下書きのテンプレートを作成 post_draft_list.htmlファイルを追加し、下書きのテンプレートを作成します。 blog/templates/blog/post_draft_list.html {% extends 'blog/base.html' %} {% block header %} Draft {% endblock %} {% block content %} {% for post in post_list %} {{ post.title }} {{ post.created_date }} {{ post.text|truncatechars:200 }} {% endfor %} {% endblock %} 投稿して、下書きページに投稿した内容が表示されるか確認してみましょう。 draftsページを開くと下書きが表示されます。 http://127.0.0.1:8000/drafts/ "},"docs/17_publish.html":{"url":"docs/17_publish.html","title":"公開機能の追加","keywords":"","body":"公開機能の追加 下書きのままでは公開されないので、公開機能を追加します。 公開ボタンを作成 Editボタンの上にPublishボタンを追加します。 blog/templates/blog/post_detail.html {% if not post.published_date %} Publish {% endif %} 公開ボタンのurlを作成 blog/urls.py path('post//publish/', views.post_publish, name='post_publish'), 公開ボタンのViewを作成 blog/views.py from django.shortcuts import render, redirect, get_object_or_404 def post_publish(request, pk): post = get_object_or_404(Post, pk=pk) post.publish() return redirect('post_detail', pk=pk) 下書きでPublishボタンをクリックすると、詳細ページにリダイレクトされます。 これで無事公開ができました。 トップページにも投稿内容が表示されているはずです。 "},"docs/18_delete.html":{"url":"docs/18_delete.html","title":"削除機能の追加","keywords":"","body":"削除機能の追加 投稿した内容を削除できる機能を追加します。 削除ボタンを作成 編集ボタンの下にDeleteボタン追加します。 blog/templates/blog/post_detail.html Delete 削除ボタンのurlを作成 blog/urls.py path('post//remove/', views.PostDeleteView.as_view(), name='post_remove'), 削除ボタンのViewを作成 blog/views.py from django.urls import reverse_lazy from django.views.generic import (TemplateView, ListView, DetailView, CreateView, UpdateView, DeleteView) class PostDeleteView(DeleteView): model = Post template_name = \"blog/post_confirm_delete.html\" success_url = reverse_lazy('post_list') テンプレートを作成 削除ボタンを押した時の画面を作成します。 post_confirm_delete.htmlファイルを作成します。 blog/templates/blog/post_confirm_delete.html {% extends 'blog/base.html' %} {% block header %} Post Delete {% endblock %} {% block content %} {% csrf_token %} {{ object }}を削除してもよろしいですか？ Delete {% endblock %} 詳細ページでDeleteボタンを押して、投稿が削除されるか確認しましょう。 Deleteボタンを押すと削除確認画面に移動します。 削除確認画面でDeleteボタンを押すと、投稿が削除されます。 これで、投稿、編集、削除機能が実装することができました。 次はセキュリティを強化していきましょう。 "},"docs/19_login_required.html":{"url":"docs/19_login_required.html","title":"セキュリティの強化","keywords":"","body":"セキュリティの強化 ログインしている人だけが投稿、編集、削除、公開をできるように修正します。 各ボタンはログインユーザーだけに表示されるように制限をしましたが、viewの中にも制御する必要があります。 viewに追記 ログインしている人だけに制限できます。 汎用ビューを使用している場合は LoginRequiredMixinを第一引数に指定 オリジナル関数 @login_requiredをデコレーターとして追記 blog/views.py from django.contrib.auth.decorators import login_required from django.contrib.auth.mixins import LoginRequiredMixin class CreatePostView(LoginRequiredMixin, CreateView): login_url = '/login/' ... class PostUpdateView(LoginRequiredMixin, UpdateView): login_url = '/login/' ... class DraftListView(LoginRequiredMixin, ListView): login_url = '/login/' ... class PostDeleteView(LoginRequiredMixin, DeleteView): ... @login_required def post_publish(request, pk): ... @login_required def post_comment(request, pk): ... ログインしている人だけが投稿、編集、削除、公開をできるようになりました。 次は、ログイン、ログアウト、サインイン機能を追加していきます。 "},"docs/20_accounts.html":{"url":"docs/20_accounts.html","title":"認証機能の追加","keywords":"","body":"認証機能を追加 会員制のWebアプリケーションを構築するには、認証機能が必須となります。 今回は、ログイン、ログアウト、サインイン機能を実装します。 別のWebアプリケーションでも再利用ができるように、認証機能は新しいアプリケーションを作成します。 認証用のアプリケーションを追加 別のアプリケーションとして作成すると、後から変更がしやすくなります。 blogと同じ要領でaccountsアプリケーションを作成します。 (myvenv) ~$ python3 manage.py startapp accounts 作成したaccountsアプリケーションをmysiteプロジェクトに登録します。 settings.pyに'accounts.apps.AccountsConfig'を追加します。 settings.py INSTALLED_APPS = [ 'blog.apps.BlogConfig', 'accounts.apps.AccountsConfig', ] django-allauthをインストール 認証機能を提供するパッケージがdjango-allauthです。 Djangoのローカル認証だけではなく、ソーシャル認証も可能になります。 GoogleアカウントやFacebookアカウントなどを使用してログインできます。 サインアップ ログイン ログアウト パスワードリセット メールアドレス認証 など、色々なことができます。 https://www.intenct.nl/projects/django-allauth/ django-allauthをインストールします。 (myvenv) ~$ pip3 install django-allauth django-allauthをアプリケーションで使用するため、プロジェクト設定を編集します。 settings.py INSTALLED_APPS = [ 'accounts.apps.AccountsConfig', 'django.contrib.sites', 'allauth', 'allauth.account', 'allauth.socialaccount', ] # 一番下に追加 SITE_ID = 1 LOGIN_REDIRECT_URL = '/' ACCOUNT_LOGOUT_REDIRECT_URL = '/' # SignUpした時に確認Emailアドレスを送信しない場合 ACCOUNT_EMAIL_VERIFICATION = 'none' # SignUpした時に確認Emailアドレスを送信する場合 # EMAIL_HOST = 'smtp.gmail.com' # EMAIL_PORT = 587 # EMAIL_HOST_USER = 'gmail adress' # EMAIL_HOST_PASSWORD = 'gmail password' # EMAIL_USE_TLS = True 今回は、メールアドレスの認証をしていませんが、もしメールアドレス認証機能を追加する場合は、設定を変更して下さい。 ルーティングを追加 認証用のルーティングは、mysiteのurls.pyのみ修正します。 mysite/urls.py urlpatterns = [ path('admin/', admin.site.urls), path('', include('blog.urls')), path('accounts/', include('allauth.urls')), # 追加 ] この1行を追加するだけで、多くの認証機能を使用することができます。 今回は、下記3つのテンプレートを作成します。 サインアップhttp://127.0.0.1:8000/accounts/signup/ ログインhttp://127.0.0.1:8000/accounts/login/ ログアウトhttp://127.0.0.1:8000/accounts/logout/ もし下記機能を使用したい場合は、テンプレートを追加して確認してみて下さい。 サインアップ(メール送信)http://127.0.0.1:8000/accounts/confirm-email/ サインアップ(確定)http://127.0.0.1:8000/accounts/confirm-email// パスワードリセットhttp://127.0.0.1:8000/accounts/password/reset/ パスワードリセット(メール送信)http://127.0.0.1:8000/accounts/password/reset/done/ パスワードリセット(パスワード設定)http://127.0.0.1:8000/accounts/password/reset/key/-set-password/ パスワードリセット(確定)http://127.0.0.1:8000/accounts/password/reset/key/done/ django-allauthのテンプレートを追加 django-allauthにはデフォルトのテンプレートがありますが、独自のテンプレートを追加していきます。 accountsフォルダの中にtemplatesフォルダ作成し、accountフォルダを作成して下さい。 その中にlogin.html、logout.html、signup.htmlを作成します。 accounts/templates/account/login.html {% extends \"blog/base.html\" %} {% block header %} Login {% endblock %} {% block content %} アカウントをまだお持ちでなければ、こちらからユーザー登録して下さい。 {% csrf_token %} {{ form.as_table }} {% if redirect_field_value %} {% endif %} パスワードをお忘れですか？ Login {% endblock %} accounts/templates/account/logout.html {% extends \"blog/base.html\" %} {% block header %} Log Out {% endblock %} {% block content %} {% csrf_token %} {% if redirect_field_value %} {% endif %} ログアウトしますか？ Log Out {% endblock %} accounts/templates/account/signup.html {% extends \"blog/base.html\" %} {% block header %} Sign Up {% endblock %} {% block content %} {% csrf_token %} {{ form.as_table }} {% if redirect_field_value %} {% endif %} Sign Up {% endblock %} ナビゲーションを変更 baseを修正して、ナビゲーションにLog out、Sign up、Loginボタンを追加します。 blog/templates/blog/base.html {% if user.is_authenticated %} Post Draft Log out {% else %} Sign up Login {% endif %} マイグレーション実行 新しくaccountsアプリケーションを追加したので、マイグレーションをする必要があります。 (myvenv) ~$ python3 manage.py migrate サーバー実行 (myvenv) ~$ python3 manage.py runserver これでユーザー認証機能が実装されました。 django-allauthを使用すると簡単に実装できます。 デザインなどは自由に変更してみて下さい。 実際にサインアップしてユーザー登録してみましょう。 ログインしたら、投稿、編集、削除ボタンが表示されていることを確認してみて下さい。 そして、ログアウトすると、投稿、編集、削除ボタンが表示されません。 "},"docs/21_comments.html":{"url":"docs/21_comments.html","title":"コメント機能の追加","keywords":"","body":"コメント機能の追加 コメントのモデルを作成 models.pyに追記します。 blog/models.py class Comment(models.Model): post = models.ForeignKey('blog.Post', on_delete=models.CASCADE, related_name='comments') author = models.CharField(max_length=200) text = models.TextField() created_date = models.DateTimeField(default=timezone.now) approved_comment = models.BooleanField(default=False) def approve(self): self.approved_comment = True self.save() def get_absolute_url(self): return reverse(\"post_list\") def __str__(self): return self.text データベースにコメントモデルのテーブルを追加 モデルを追加した場合は、必ずデータベースを更新して下さい。 (myvenv) ~$ pthon3 manage.py makemigrations blog (myvenv) ~$ python3 manage.py migrate blog 管理画面にコメントモデルを登録 管理画面でコメントを操作できるようにします。 blog/admin.py from django.contrib import admin from .models import Post, Comment admin.site.register(Post) admin.site.register(Comment) 管理画面にアクセスするとコメントの追加や削除が出来るようになっています。 http://127.0.0.1:8000/admin/blog/comment/ コメントを表示 最後のendblockの前に追記します。 blog/templates/blog/post_detail.html {{ post.text|linebreaksbr }} {% for comment in post.comments.all %} {{ comment.created_date }} {{ comment.author }} {{ comment.text|linebreaks }} {% empty %} まだコメントはありません。 {% endfor %} {% endblock %} 投稿ページでコメントの数を表示します。 blog/templates/blog/post_list.html {{ post.text|linebreaksbr|truncatechars:100 }} Comments: {{ post.comments.count }} {% endfor %} コメントを投稿 forms.pyファイルを変更します。 blog/forms.py from django import forms from .models import Post, Comment class CommentForm(forms.ModelForm): class Meta: model = Comment fields = ('author', 'text',) コメントボタンを作成 blog/templates/blog/post_detail.html Add comment {% for comment in post.comments.all %} コメントのurlを作成 blog/urls.py path('post//comment/', views.post_comment, name='post_comment'), コメントのViewを作成 blog/views.py from blog.forms import PostForm, CommentForm @login_required def post_comment(request, pk): post = get_object_or_404(Post, pk=pk) if request.method == \"POST\": form = CommentForm(request.POST) if form.is_valid(): comment = form.save(commit=False) comment.post = post comment.save() return redirect('post_detail', pk=post.pk) else: form = CommentForm() return render(request, 'blog/post_comment.html', {'form': form}) コメントを投稿するテンプレートを作成 blog/templates/blog/post_comment.html {% extends 'blog/base.html' %} {% block header %} New comment {% endblock %} {% block content %} {% csrf_token %} {{ form.as_p }} Send {% endblock %} コメントを管理 コメントを承認または削除できるようにします。 RemoveボタンとApproveボタンを追加します。 blog/templates/blog/post_detail.html {% for comment in post.comments.all %} {% if not comment.approved_comment %} Remove Approve {% endif %} コメント管理のurlを作成 blog/urls.py path('comment//approve/', views.comment_approve, name='comment_approve'), path('comment//remove/', views.comment_remove, name='comment_remove'), コメント管理のViewを作成 blog/views.py from blog.models import Post, Comment @login_required def comment_approve(request, pk): comment = get_object_or_404(Comment, pk=pk) comment.approve() return redirect('post_detail', pk=comment.post.pk) @login_required def comment_remove(request, pk): comment = get_object_or_404(Comment, pk=pk) comment.delete() return redirect('post_detail', pk=comment.post.pk) これで、コメントの承認と削除ができるようになりました。 承認されたコメント数を表示 blog/templates/blog/post_list.html {{ post.text|linebreaksbr|truncatechars:100 }} Comments: {{ post.approved_comments.count }} {% endfor %} モデルを追加 Postモデルに追加します。 blog/models.py class Post(models.Model): def approved_comments(self): return self.comments.filter(approved_comment=True) これでコメント機能が実装されました。 コメントボタンをクリックしてコメントが投稿できるか試してみて下さい。 "},"docs/22_javascript.html":{"url":"docs/22_javascript.html","title":"JavaScriptの追加","keywords":"","body":"JavaScriptで動きをつける スクロールした時にナビゲーションが表示される動きを付けます。 base.htmlにJavaScriptを追記します。 blog/templates/blog/base.html blog/static/jsフォルダを作成します。 └── blog └── static └── js └── blog.js blog.jsファイルを作成します。 JavaScript:blog/static/js/blog.js \"use strict\"; const mainNav = document.querySelector(\"#mainNav\") // windowの幅が992px以上の場合 if (window.innerWidth > 992) { let previousTop = 0; // スクロールイベント window.addEventListener('scroll', (e) => { // トップを取得 let currentTop = document.documentElement.scrollTop || document.body.scrollTop; if (currentTop 0 && mainNav.classList.contains('is-fixed')) { mainNav.classList.add(\"is-visible\"); } else { // スクロールTOP mainNav.classList.remove(\"is-visible\", \"is-fixed\"); } } else if (currentTop > previousTop) { // スクロールDOWN mainNav.classList.remove(\"is-visible\"); if (currentTop > mainNav.clientHeight && !mainNav.classList.contains('is-fixed')) { mainNav.classList.add(\"is-fixed\"); } } previousTop = currentTop; }); } 下にスクロールして、上にスクロールするとナビゲーションが表示するようになりました。 "},"docs/23_header_image.html":{"url":"docs/23_header_image.html","title":"ヘッダー画像の追加","keywords":"","body":"ヘッダー画像の追加 各投稿ページのヘッダー画像を変更する機能を追加します。 デフォルト画像の追加 デフォルトで表示する画像を追加します。 blog/static/imgフォルダを作成して、その中にtitle.pngを追加します。 └── blog └── static └── img └── title.png フリー素材を使用して、好きな画像をタイトルに追加しましょう。 https://pixabay.com/ ブログで使用する画像は、著作権に気を付けて下さい。 自分で撮影した画像は問題ありません。 画像圧縮 画像のサイズが重いと表示速度に影響が出ますので、下記のサイトを使用して、画像を圧縮してから保存します。 幅：1920px 縦：500px あまりに大きいサイズの画像は必要ありませんので、画像編集ソフトでトリミングしておきます。 https://imagecompressor.com/ja/ 画像変更機能追加 投稿画面で画像ファイルを指定して、ヘッダー画像として表示します。 画像格納フォルダを作成 ルートディレクトリにimagesフォルダを作成します。 /images/ 画像ライブラリをインストール Pythonの画像処理ライブラリPillowをインストールします。 (myvenv) ~$ pip3 install pillow 設定ファイルを変更 settings.pyを変更して、追加したimagesフォルダを認識するようにします。 settings.py IMAGE_ROOT = os.path.join(BASE_DIR, 'images') IMAGE_URL = '/images/' 画像フォルダをurlsに追加 画像フォルダの場所をurlsに追加して、画像を使用できるようにします。 mysite/urls.py from django.conf.urls.static import static from django.conf import settings urlpatterns += static(settings.IMAGE_URL, document_root=settings.IMAGE_ROOT) 画像のモデルを追加 画像をアップロードしたいので、モデルに追加します。 ImageFieldを使用します。 upload_toでアップロードする画像の場所を指定します。 blog/models.py class Post(models.Model): author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE) image = models.ImageField(upload_to='images',blank=True, null=True)　# 追加 フィールドを追加 forms.pyにimageフィールドを追加します。 blog/forms.py class PostForm(forms.ModelForm): class Meta: model = Post fields = ('author', 'title', 'text', 'image')　# 追加 テンプレートを変更 投稿画面で画像を投稿できるようにします。 formにenctype=\"multipart/form-data\"を追加します。 画像をアップロードするにはこの指定が必要になります。 blog/templates/blog/post_edit.html {% block content %} {% csrf_token %} {{ form.as_p }} Save {% endblock %} 詳細画面のヘッダーで画像が表示されるようにします。 CSSでbackground-imageを上書きしています。 blog/templates/blog/post_detail.html {% if post.image %} header.masthead { background-image: url('/{{ post.image.url }}') !important; } {% endif %} {{ post.text|linebreaksbr }} マイグレーション実行 モデルを変更したので、マイグレーションをする必要があります。 (myvenv) ~$ python3 manage.py makemigrations (myvenv) ~$ python3 manage.py migrate サーバー実行 (myvenv) ~$ python3 manage.py runserver 投稿画面で画像をアップロードできるようになりました。 画像をアップロードして、ヘッダーの画像が変更されるか確認してみましょう。 Herokuを使う場合 ※Heroku以外を使用する方は飛ばして下さい。 今回、WebサーバーはHerokuを使用します。 しかし、Herokuは画像、動画のアップロードに対応していません。 そこで、cloudinaryを使用します。 Cloudinaryとは Cloudinaryは、メディアファイルのアップロードやクラウド上のストレージへの保管ができるサービスです。 https://cloudinary.com/ アカウントの作成 右上ボタンの「SING UP FOR FREE」ボタンを押して、アカウントを作成して下さい。 Account Detailにユーザー情報が表示されます。 Cloud name: xxx API Key: xxx API Secret: xxx cloudinaryをインストール cloudinaryをインストールします。 pip3 install install django-cloudinary-storage Herokuにcloudinaryをインストール Herokuにcloudinaryのaddonをインストールします。 heroku addons:add cloudinary:starter 設定変更 Account Detailに表示された情報をCLOUDINARY_STORAGEに追加します。 INSTALLED_APPS = [ ... 'cloudinary', # 追加 'cloudinary_storage',# 追加 ] # 追加 DEFAULT_FILE_STORAGE = 'cloudinary_storage.storage.MediaCloudinaryStorage' # 追加 CLOUDINARY_STORAGE = { 'CLOUD_NAME': 'xxx', 'API_KEY': 'xxx', 'API_SECRET': 'xxx' } テンプレート変更 urlのスラッシュを削除します。 ローカルに保存する場合は必要でしたが、今はクラウドに保存するので、必要がなくなりました。 blog/templates/blog/post_detail.html {% if post.image %} header.masthead { background-image: url('{{ post.image.url }}') !important; } {% endif %} 画像フォルダ削除 先ほど追加したimagesフォルダは必要ないので削除します。 /images/ サーバー実行 (myvenv) ~$ python3 manage.py runserver これで画像の保存先がcloudinaryとなり、Herokuでも画像が投稿できるようになりました。 投稿画面で試してみましょう。 "},"docs/24_about.html":{"url":"docs/24_about.html","title":"固定ページの追加","keywords":"","body":"固定ページの追加 固定ページを追加します。 自己紹介をするAboutページやコンタクトページなど自由に作成してみて下さい。 ナビゲーションにaboutボタンを追加します。 html:blog/templates/blog/base.html About urlを追加 blog/urls.py path('about/', views.AboutView.as_view(), name='about'), Viewを追加 blog/views.py from django.views.generic import (TemplateView, ListView, DetailView, CreateView, UpdateView, DeleteView) class AboutView(TemplateView): template_name = 'page/about.html' テンプレートを追加 /templates/pageフォルダを作成し、about.htmlを追加します。 内容は自由に記載して下さい。 自己紹介を書くといいと思います。 レイアウトを考えて、CSSに追記してみて下さい。 blog/templates/page/about.html {% extends 'blog/base.html' %} {% block header %} About {% endblock %} {% block content %} 自由に記載して下さい。 {% endblock %} 完成 ブログアプリケーションの構築が完了です。 記事の投稿、編集、削除、公開、コメント、ログイン、ログアウトなどの機能を操作して、問題がないか確かめて下さい。 問題がなければ、次は全世界に公開します。 "},"docs/25_pagenation.html":{"url":"docs/25_pagenation.html","title":"ページネーション機能の追加","keywords":"","body":"ページネーション機能の追加 ページネーション機能を追加します。 ページネーションとは ページネーションとは、内容の多いページを複数のページに分割し、各ページへのリンクを並べてアクセスしやすくする機能です。 Djangoでは簡単にページネーション機能が実装できます。 ページネーションをViewに追加 paginate_by変数をオーバーライドするだけで、ページネーションが実装できます。 好きな数字を代入して下さい。 今回は、3投稿ずつ表示するようにします。 blog/views.py class PostListView(ListView): model = Post template_name = \"blog/post_list.html\" paginate_by = 3 # 追加 ページネーションをテンプレートに追加 一番下のendblockの上に追加します。 blog/templates/blog/post_list.html {% if page_obj.has_previous %} Prev {% endif %} {% for num in page_obj.paginator.page_range %} {% if page_obj.number == num %} {{ num }} {% else %} {{ num }} {% endif %} {% endfor %} {% if page_obj.has_next %} Next {% endif %} {% endblock %} これだけで、ページネーションが実装できました。 ページネーションをクリックして、ページが分割されているか確認してみて下さい。 "},"docs/26_deploy.html":{"url":"docs/26_deploy.html","title":"Herokuデプロイ","keywords":"","body":"Herokuデプロイ デプロイとは、特定の環境下でアプリケーションやシステムを使えるようにすることです。 Herokuにデプロイして、Webアプリケーションを世界中に公開しましょう。 デプロイすることによって、多くの人にあなたのWebアプリケーションを使ってもらえるようになります。 デプロイ準備 パッケージ定義 freezeコマンドをすることによって、アプリを動かすためのパッケージを一覧にまとめることができます。 (myvenv) ~$ pip3 freeze > requirements.txt このような内容になります。バージョンは実行時期によって異なります。 requirements.txt asgiref==3.2.3 dj-database-url==0.5.0 Django==2.2.10 django-heroku==0.3.1 gunicorn==19.9.0 psycopg2==2.8.4 pytz==2019.3 sqlparse==0.3.0 whitenoise==5.0.1 Procfile作成 Procfileは、アプリのプロセスタイプやエントリーポイントを宣言するファイルです。 Procfileを作成します。 django-blog └── Procfile Procfile web: gunicorn mysite.wsgi mysiteの部分はあなたが作成したアプリのディレクトリ名を指定します。 gunicornと、HerokuでDjangoをデプロイするときに必要なWebサーバーです。 runtime.txt作成 runtime.txtにはプログラム実行時に必要なものを定義します。 ここではPythonが必要なのでPythonのバージョンを指定します。 runtime.txtを作成します。 django-blog └── runtime.txt runtime.txt python-3.6.9 Herokuを操作 Herokuにデプロイする準備ができましたので、Herokuを操作していきます。 Herokuアカウント作成 まずはHerokuのアカウントを作成します。 https://signup.heroku.com/ Heroku CLIインストール OSに合わせてHeroku CLIをインストールします。 インストールすることによって、コマンドラインからHerokuの操作が出来るようになります。 https://devcenter.heroku.com/articles/getting-started-with-python Herokuにログイン ターミナルからHerokuにログインします。 $ heroku login コマンドを実行すると、ログイン用のWebページが表示されますので、ログインボタンを押して下さい。 Herokuプロジェクト作成 Herokuにプロジェクトを作成します。 好きなプロジェクト名を指定して下さい。 このプロジェクト名がURLになりますので、既に他の人に使われているプロジェクト名は指定できません。 $ heroku create django-blog このように表示されたら成功です。 Creating ⬢ django-blog... done https://django-blog.herokuapp.com/ | https://git.heroku.com/django-blog.git Herokuにpush Herokuにpushする前に、GitHubにすべてコミットしておいて下さい。 $ git push heroku master デプロイ完了とメッセージが表示されます。 remote: https://django-blog.herokuapp.com/ deployed to Heroku remote: remote: Verifying deploy... done. To https://git.heroku.com/django-blog.git * [new branch] master -> master プロセスを起動 このままだとgunicornのサーバーが起動していないため、アプリケーションが起動しません。 以下のコマンドで起動します。 $ heroku ps:scale web=1 このように表示されたら成功です。 Scaling dynos... done, now running web at 1:Free Herokuのデータベースを構築 migrateコマンドをしてデータベースを構築します。 $ heroku run python manage.py migrate このように表示されたら成功です。 Running python manage.py migrate on ⬢ django-blog... up, run.5146 (Free) Operations to perform: Apply all migrations: admin, auth, blog, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying auth.0010_alter_group_name_max_length... OK Applying auth.0011_update_proxy_permissions... OK Applying blog.0001_initial... OK Applying blog.0002_comment... OK Applying sessions.0001_initial... OK 管理ユーザーを作成 ローカルと同じようにHerokuでも管理ユーザーを作成することができます。 $ heroku run python manage.py createsuperuser ユーザー名、メールアドレス、パスワードを入力します。 パスワードの入力は表示されませんので、間違えずに入力して下さい。 Running python manage.py createsuperuser on ⬢ django-blog... up, run.6023 (Free) ユーザー名: メールアドレス: Password: Password (again): Superuser created successfully. これで無事デプロイ完了です。 デプロイしたURLにアクセスしてみましょう。 ローカルと同じ画面が表示されているはずです。 最初はデータがない初期状態なので、ブログを投稿してみましょう。 セキュリティを高める デプロイは成功しましたが、セキュリティ上の問題があります。 DebugをFalse 現在、Debug機能が有効になっているため、もしエラーが発生した場合、詳細な情報が表示されてしまいます。 ローカルではいいのですが、本番環境で詳細な情報は表示されたくありません。 .gitignoreファイルに、local_settings.pyを追記します。 .gitignore ... local_settings.py local_settings.pyファイルを作成します。 ローカルのみDEBUG機能を有効にします。 mysite/local_settings.py import os BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } DEBUG = True setting.pyを変更します。 mysite/settings.py # Falseに変更 DEBUG = False # 追加 try: from .local_settings import * except ImportError: pass # Debug=Falseの時だけ実行する設定 if not DEBUG: import django_heroku django_heroku.settings(locals()) GitHubにコミットしておきます。 Herokuにもpushします。 $ git push heroku master これで本番環境でデバッグ機能が無効になり、詳細な情報が表示されなくなりました。 存在しないURLを打ってみましょう。 Not Foundと表示されるはずです。 ローカルで存在しないURLを打ってみると、詳細な情報が表示されます。 SECRET KEYがハードコーディングされている セキュリティ上、SECRET KEYを直接書くのは良くありません。 先ほど作成した、local_settings.pyにSECRET_KEYを移動させましょう。 mysite/local_settings.py # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = 'xxxxxxxxxxxxxxxxxxxx' settings.pyのSECRET_KEYは削除します。 mysite/settings.py # 削除 SECRET_KEY = 'xxxxxxxxxxxxxxxxxxxx' if not DEBUG: import django_heroku django_heroku.settings(locals()) SECRET_KEY = os.environ['SECRET_KEY'] 本番環境でSECRET_KEYを設定するには、heroku config:setコマンドを使います。 実際のSECRET_KEYに置き換えて実行します。 $ heroku config:set SECRET_KEY=\"xxxx\" heroku configコマンドでHerokuの環境変数を見ることができます。 $ heroku config SECRET_KEYが表示されていれば成功です。 本番環境が動作するか確認しておきましょう。 DjangoでWebアプリケーションの作成方法が分かったのではないでしょうか。 ぜひ色々試して機能を追加して、さらに理解を深めていきましょう。 以上 "},"docs/27_finish.html":{"url":"docs/27_finish.html","title":"おわりに","keywords":"","body":"おわりに チュートリアルを最後まで読んでいただき、誠にありがとうございました。 ブログ構築チュートリアルはここまでで終わりとなります。 Webアプリケーション開発の流れは理解出来ましたでしょうか！？ Djangoは奥の深いフレームワークで、多くの機能を搭載することができます。 公式ドキュメントを参考にして、さらに理解を深めていきましょう。 https://docs.djangoproject.com/ja/2.2/ これまでの知識で基本的なWebアプリケーションを開発できます。 ぜひオリジナルのアプリケーションを開発してみてください。 フィードバック チュートリアルのフィードバックは、Twitter(@hathle)までお願いいたします。 チュートリアル構成 Djangoチュートリアルは3段階構成にします。 ステップ1 ★https://haruyasu.github.io/django-tutorial/ 基本的なWebアプリ開発の流れを学習 ブログシステム構築 ステップ2 ★★ APIの使い方を学習 レストラン検索、口コミシステム構築 ステップ3 ★★★ Django Rest Frameworkを使用してAPI実装を学習 バックエンド：Django フロントエンド：Vue.js どんどんDjangoチュートリアルを作成していきますので、楽しみにしていてください。 ではまた！！ "}}